/*****************************************************************************
*  文件名称  ： 
*    作者    ： 
*    时间    ： 
******************************************************************************/




在自由模式时，只能T1STAT 的OVFIF 或者T1IF来判断，因为只要T1CNT超过0xFFFF时才
会置位。


（模模式）/（正计数/负计数）需要开启通道0的输出比较模式，否则计数器只有到了0XFF
时才会产生溢出中断（相应的产生溢出标志），也就是如果没有设置通道0的输出比较模式，
计数器的值到达T1CC0后，不会产生溢出中断（相应的溢出标志不会置1），这点需要特别注
意。



当在摸模式或者正计数/负计数下，T1CNT到达T1CC0的时候，将会置位
T1STAT中对应的通道标志CH0IF。但如果开始计数时T1CNT在T1CC0上,在达到0xFFFF时，会置位
T1STAT 的OVFIF 或者T1IF。

系统在不配置工作频率时默认为2分频，即32M/2=16M,所以定时器每次溢出时间：
1分频：T = 1 / (16M / 1)*65536 = 0.004096s
8分频：T = 1 / (16M / 8)*65536 = 0.032768s
32分频：T = 1 / (16M / 32)*65536 = 0.131072s
128分频：T = 1 / (16M / 128)*65536 = 0.524s

1分频,T1CC为1600时：T = 1 / (16M / 1)*1600 = 0.000100s

判断的时候用的什么  清除的时候就清除什么。
例如：针对Time1的0通道。

  int time1ChannalValue(int channal)
  {
       return ( T1STAT & (1 << 0) );
  }

  
  void time1ChannalClear(int channal)
  {
    T1STAT &= ~(1 << channal);
  }

  int time1Value()
  {
       return T1IF;
  }

  void time1Clear()
  { 
      T1IF = 0;
  }



在使用模模式（或者正计数/负计数模式）的时候，要设置通道0为比较模式，
例如：Time1的0通道。
T1CCTL0 |= (1 << 2);

设置模的值（比较的值）。
setT1CCxValue(1600, 0); //通道0的T1CC0 位1600

使用time1的自由模式
void main()
{
  unsigned int count = 0;
  int ledstatus = 0;
  ledInit();                       //初始化选择的LED
  initTime1(TIME_CLOCK_DIV_1,TIME_FREERUNNING, 0);   //初始化time1
  //setT1CCxValue(1600, 0);          //设置模 模式   ,使用模模式的时候使用
  while(1) 
  {
    if( time1ChannalValue(5) )      //判断有无溢出
    {
      count++ ;
      if(count > 250)
      {
        count = 0;
        ledstatus = ~ledstatus;
      }
      
      time1ChannalClear(5);
    }
    
    if(ledstatus)
    {
      led1On();
    }
    else
    {
      led1Off();
    }
    
  }
}




定时器3 总结：
1、当系统不配置工作频率时，即为16M工作频率下，定时器每递增需要时间为1/(16000000/
128) = 8us。当采用自由运行模式下，每溢出一次需要时间为：2ms
2、定时器3采用中断方式，初始化需要做的事情：1）开启总中断 EA = 1;  2）使能定时
器3中断   3）使能溢出中断(默认使能)   4）设置分频、运行模式    5）最后启动定时器3 



定时器3和定时器4的倒模式还没有写好，问题：当设置为倒模式时。TxCNT不计数，一直都是
0x00